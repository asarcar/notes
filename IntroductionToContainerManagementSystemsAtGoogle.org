https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44843.pdf
* History
** Containers
1. chroot originally used to separate and isolate file system
namespaces was extended to process IDs, networking, etc. 
2. cGroups a linux kernel feature was developed to limit,
account for, and isolate resource usage, such as CPU, memory,
disk I/O, network, etc.
These allow systems, such as Kubernetes, to manage different 
task flavors running on the same OS/kernel by hermitically sealing 
them into units (aka containers) that protect apps from noisey,
nosey, and messy neighbors as well as encapsulating most
app dependencies into container packages!
Note:
1. The isolation cannot prevent interference of non kernel resources, 
such as level-3 processor caches and memory bandwidth. 
2. Additional security layers of VMs are still needed to protect 
against malicious cloud actors.
3. Apps are still exposed to churn in OS interface, such as
kernel system-call interface e.g. socket options, /proc and args, 
ioctl calls, etc.
** Borg
   Resource Management and Scheduling of latency sensitive and batch jobs.
** Omega
Cleaned up the hodge podge of tools built by separating out cluster state 
in a paxos oriented transaction store and the cluster control
plane that handles different aspects of scheduling using multiple peers 
that interact with the cluster state store.
** Kubernetes
Takes Omega a step further for cloud development community to 
ensure developers are not encumbered with aspects of distributed 
task development, such as naming, discovery, load-balancing, 
monitoring, auto-scaling, etc. by ensuring all the interactions are
realized via APIs that are validated, versioned, etc.

Container encompasses the runtime isolation as well as the image 
registry and managment system that provides the following services:
(a) package files that make up the app running inside containers.  
(b) package manager, build, and deployment tools of the images.

* App Oriented Infrastructure
** Encapsulation
Containers encapsulate app environment abstracting machine and 
OS details from developer and deployment infrastructure.
** Management Unit
Containers and container images are scoped to a single application.
As such, by managing containers one manages apps not machines.

* Containers as "unit of management"
1. Relieves app developers and ops team from mc and os details.
2. Infra teams roll out new mc and upgrade os unencumbered by 
running apps and developers.
3. Telemetry collection (CPU/Memory) is app rather than mc centric
improving app monitoring and introspection even under scale up, 
mc failures, or maintenance causing app instance migration.
3.1. App health exported via HTTP endpoint.
3.2. KV annotations to communicate to/from containers.
3.3. cGroups allow app specific metric exported via HTTP APIs. 
4. Managment layer is apps not mc. LB keyed by app not mc. 
Logs are keyed, collected, and aggregated by app not teased
apart from mc logs. App failures not teased apart from mc 
failure signals.
* Nested Containers 
Outermost Pods (Alloc) provides pool of resources. 
Inner one provide deployment isolation.
* Container Management Services
+ Development environment to manage reliable distributed system apps
 ++ Naming and Service Discovery
 ++ Master Election (Raft/Chubby)
 ++ App aware LB
 ++ Autoscaling Instances - Scale out and Scale Up 
 ++ Deployment of new binaries and config data
 ++ Workflow - run multijob analysis pipelines
 ++ Monitoring - gather container info, aggregate, dashboard, alert, ...

* Kubernetes Service Object
** Object Metadata
Object Name, UID, Version # (optimistic concurrency control), and
labels i.e. (K,V) pairs.
** Spec
Describe the desired state of the object.
** Status
Read only information about current state of object.

* Choreograph vs Orchestrate
Control through a combination of microservices and 
small control loops achieves a desired emergent behavior. 
Effect is achieved via choreographed collaboration of separate
autonomous entities. 
Note centralized orchestration systems are easier to construct 
but becomes brittle and rigid over time in presence of 
unanticipated errors or state changes.

* Kubernetes Attributes
1. IP address per POD aligns network and app identity.
2. Tags i.e. Labels are dynamically manipulated (K,V) pairs 
ascribed to objects e.g. POD object labels: role=frontend 
and stage=production. 
3. Grouping mechanism is Label selectors (e.g. stage=production 
&& role==frontend) define set of objects.
